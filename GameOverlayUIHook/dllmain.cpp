#include <windows.h>
#include <iostream>
#include <tlhelp32.h>
#include "VMProtectSDK.h"
#pragma comment(lib,"VMProtectSDK32.lib")
#include "obfuscation.h"
using namespace std;
#include "SDK.h"
//#include "breakpoint.h"

__forceinline void SMKOZGZ070P8()
{
	//junkcode
	int D2H4DJESOA7CJ = 251367161;
	if (D2H4DJESOA7CJ > 251367154)
		D2H4DJESOA7CJ = 251367128;
	else if (D2H4DJESOA7CJ <= 251367168)
		D2H4DJESOA7CJ++;
	else
		D2H4DJESOA7CJ = (251367179 / 251367166);
	bool DG6SK98740CKP = true;
	if (!DG6SK98740CKP)
		DG6SK98740CKP = true;
	else if (DG6SK98740CKP = true)
		DG6SK98740CKP = true;
	else
		DG6SK98740CKP = true;
	bool D16R2A4ZA5WKR = false;
	if (!D16R2A4ZA5WKR)
		D16R2A4ZA5WKR = true;
	else if (D16R2A4ZA5WKR = true)
		D16R2A4ZA5WKR = true;
	else
		D16R2A4ZA5WKR = true;
	int DDSES5C3IXB0B = 251367187;
	if (DDSES5C3IXB0B > 251367118)
		DDSES5C3IXB0B = 251367108;
	else if (DDSES5C3IXB0B <= 251367123)
		DDSES5C3IXB0B++;
	else
		DDSES5C3IXB0B = (251367110 / 251367107);
	int DJD55RON4Y04R = 251367109;
	if (DJD55RON4Y04R > 251367194)
		DJD55RON4Y04R = 251367155;
	else if (DJD55RON4Y04R <= 251367133)
		DJD55RON4Y04R++;
	else
		DJD55RON4Y04R = (251367117 / 251367112);
	bool D9L8D16I270S3 = true;
	if (!D9L8D16I270S3)
		D9L8D16I270S3 = false;
	else if (D9L8D16I270S3 = true)
		D9L8D16I270S3 = true;
	else
		D9L8D16I270S3 = true;
	bool DBA11L04RS4HA = false;
	if (!DBA11L04RS4HA)
		DBA11L04RS4HA = false;
	else if (DBA11L04RS4HA = true)
		DBA11L04RS4HA = false;
	else
		DBA11L04RS4HA = false;
	bool D8YI6PBH70M7H = true;
	if (!D8YI6PBH70M7H)
		D8YI6PBH70M7H = false;
	else if (D8YI6PBH70M7H = true)
		D8YI6PBH70M7H = true;
	else
		D8YI6PBH70M7H = true;
	int D93IEQGCBJP4L = 251367116;
	if (D93IEQGCBJP4L > 251367193)
		D93IEQGCBJP4L = 251367102;
	else if (D93IEQGCBJP4L <= 251367125)
		D93IEQGCBJP4L++;
	else
		D93IEQGCBJP4L = (251367157 / 251367177);
	bool DF5BGNPC2HYZY = true;
	if (!DF5BGNPC2HYZY)
		DF5BGNPC2HYZY = true;
	else if (DF5BGNPC2HYZY = false)
		DF5BGNPC2HYZY = true;
	else
		DF5BGNPC2HYZY = true;
	bool D2WM5I40F5N7G = true;
	if (!D2WM5I40F5N7G)
		D2WM5I40F5N7G = true;
	else if (D2WM5I40F5N7G = true)
		D2WM5I40F5N7G = false;
	else
		D2WM5I40F5N7G = true;
	int DHHY670IZGMSZ = 251367112;
	if (DHHY670IZGMSZ > 251367160)
		DHHY670IZGMSZ = 251367166;
	else if (DHHY670IZGMSZ <= 251367162)
		DHHY670IZGMSZ++;
	else
		DHHY670IZGMSZ = (251367195 / 251367179);
	int DOSOO6KDSJ525 = 251367155;
	if (DOSOO6KDSJ525 > 251367143)
		DOSOO6KDSJ525 = 251367140;
	else if (DOSOO6KDSJ525 <= 251367191)
		DOSOO6KDSJ525++;
	else
		DOSOO6KDSJ525 = (251367160 / 251367183);
	bool D3GPX093G35EQ = true;
	if (!D3GPX093G35EQ)
		D3GPX093G35EQ = true;
	else if (D3GPX093G35EQ = true)
		D3GPX093G35EQ = false;
	else
		D3GPX093G35EQ = false;
	bool DGELE95I8DP95 = false;
	if (!DGELE95I8DP95)
		DGELE95I8DP95 = false;
	else if (DGELE95I8DP95 = true)
		DGELE95I8DP95 = false;
	else
		DGELE95I8DP95 = true;
	int DGCEZXPN9FKIS = 251367129;
	if (DGCEZXPN9FKIS > 251367167)
		DGCEZXPN9FKIS = 251367193;
	else if (DGCEZXPN9FKIS <= 251367155)
		DGCEZXPN9FKIS++;
	else
		DGCEZXPN9FKIS = (251367119 / 251367167);
	int D09KC604Z9GOC = 251367136;
	if (D09KC604Z9GOC > 251367112)
		D09KC604Z9GOC = 251367143;
	else if (D09KC604Z9GOC <= 251367131)
		D09KC604Z9GOC++;
	else
		D09KC604Z9GOC = (251367177 / 251367135);
	bool D7MKKCJ7OE5CW = true;
	if (!D7MKKCJ7OE5CW)
		D7MKKCJ7OE5CW = false;
	else if (D7MKKCJ7OE5CW = true)
		D7MKKCJ7OE5CW = false;
	else
		D7MKKCJ7OE5CW = true;
	bool DE78OSX4PF3X6 = false;
	if (!DE78OSX4PF3X6)
		DE78OSX4PF3X6 = true;
	else if (DE78OSX4PF3X6 = false)
		DE78OSX4PF3X6 = true;
	else
		DE78OSX4PF3X6 = false;
	int DG2H1W3M9CMGE = 251367122;
	if (DG2H1W3M9CMGE > 251367129)
		DG2H1W3M9CMGE = 251367171;
	else if (DG2H1W3M9CMGE <= 251367176)
		DG2H1W3M9CMGE++;
	else
		DG2H1W3M9CMGE = (251367125 / 251367192);
	bool DALD5LWQZ09AE = false;
	if (!DALD5LWQZ09AE)
		DALD5LWQZ09AE = true;
	else if (DALD5LWQZ09AE = false)
		DALD5LWQZ09AE = true;
	else
		DALD5LWQZ09AE = false;
	bool DC2JQWRCERB0P = true;
	if (!DC2JQWRCERB0P)
		DC2JQWRCERB0P = true;
	else if (DC2JQWRCERB0P = false)
		DC2JQWRCERB0P = true;
	else
		DC2JQWRCERB0P = false;
	int DRXHCRLWNISB8 = 251367190;
	if (DRXHCRLWNISB8 > 251367107)
		DRXHCRLWNISB8 = 251367188;
	else if (DRXHCRLWNISB8 <= 251367160)
		DRXHCRLWNISB8++;
	else
		DRXHCRLWNISB8 = (251367134 / 251367163);
	int DNQ0H7PF1G1FA = 251367170;
	if (DNQ0H7PF1G1FA > 251367126)
		DNQ0H7PF1G1FA = 251367154;
	else if (DNQ0H7PF1G1FA <= 251367146)
		DNQ0H7PF1G1FA++;
	else
		DNQ0H7PF1G1FA = (251367126 / 251367101);
	bool D55H41HJE700J = false;
	if (!D55H41HJE700J)
		D55H41HJE700J = true;
	else if (D55H41HJE700J = true)
		D55H41HJE700J = true;
	else
		D55H41HJE700J = true;
	int D4ZKM96EG7EN0 = 251367178;
	if (D4ZKM96EG7EN0 > 251367160)
		D4ZKM96EG7EN0 = 251367129;
	else if (D4ZKM96EG7EN0 <= 251367175)
		D4ZKM96EG7EN0++;
	else
		D4ZKM96EG7EN0 = (251367195 / 251367186);
	bool D6CZ693M604QP = true;
	if (!D6CZ693M604QP)
		D6CZ693M604QP = true;
	else if (D6CZ693M604QP = false)
		D6CZ693M604QP = true;
	else
		D6CZ693M604QP = true;
	bool DIG4SR0I5E3FN = true;
	if (!DIG4SR0I5E3FN)
		DIG4SR0I5E3FN = false;
	else if (DIG4SR0I5E3FN = true)
		DIG4SR0I5E3FN = false;
	else
		DIG4SR0I5E3FN = true;
	int DAR13LN9XH2CO = 251367111;
	if (DAR13LN9XH2CO > 251367194)
		DAR13LN9XH2CO = 251367131;
	else if (DAR13LN9XH2CO <= 251367176)
		DAR13LN9XH2CO++;
	else
		DAR13LN9XH2CO = (251367131 / 251367178);
	int DFHM2833G8RWY = 251367111;
	if (DFHM2833G8RWY > 251367147)
		DFHM2833G8RWY = 251367125;
	else if (DFHM2833G8RWY <= 251367124)
		DFHM2833G8RWY++;
	else
		DFHM2833G8RWY = (251367104 / 251367197);
	int DJ5M0EMKW0GXP = 251367171;
	if (DJ5M0EMKW0GXP > 251367115)
		DJ5M0EMKW0GXP = 251367153;
	else if (DJ5M0EMKW0GXP <= 251367193)
		DJ5M0EMKW0GXP++;
	else
		DJ5M0EMKW0GXP = (251367157 / 251367153);
	bool DJMPPX18D4KX6 = true;
	if (!DJMPPX18D4KX6)
		DJMPPX18D4KX6 = true;
	else if (DJMPPX18D4KX6 = true)
		DJMPPX18D4KX6 = true;
	else
		DJMPPX18D4KX6 = false;
}

ISetup* g_pSetup = NULL;
ISurface* g_pSerializedSurface = NULL;
ISurface039* p_ISurface039 = NULL;
IPanel* g_pPanel = NULL;
IInputInternal* g_pIInput = NULL;
typedef void(__stdcall* PaintTraverse_t)(VPANEL panel);
PaintTraverse_t pPaintTraverse = NULL;
DWORD TableAddr;
LPVOID exposeCache;
LPVOID internalCache;
LPVOID informationCache;
HANDLE g_dwMainThread;
HANDLE hFile;
LPTSTR hText;

typedef struct drawType_FilledRect
{
	short int x;
	short int y;
	short int width;
	short int height;
	BYTE r, g, b, a;
};
typedef struct drawType_OutlinedRect
{
	short int x;
	short int y;
	short int width;
	short int height;
	BYTE r, g, b, a;
};
typedef struct drawType_Line
{
	short int x1;
	short int y1;
	short int x2;
	short int y2;
	BYTE r, g, b, a;
};
typedef struct drawType_Circle
{
	short int x;
	short int y;
	short int radius;
	BYTE r, g, b, a;
};
typedef struct drawType_Text
{
	short int x;
	short int y;
	BYTE fonttype;
	BYTE r, g, b, a;
};
void d2l_Bresenham(int p1_x, int p1_y, int p2_x, int p2_y, int r, int g, int b, int a)
{
	int dx = p2_x - p1_x;
	int dy = p2_y - p1_y;
	int ux = ((dx > 0) << 1) - 1;
	int uy = ((dy > 0) << 1) - 1;
	int x = p1_x, y = p1_y, eps;
	int p_x;
	int p_y;
	eps = 0;
	dx = abs(dx);
	dy = abs(dy);
	if (dx > dy) {
		for (x = p1_x; x != p2_x; x += ux) {
			p_x = x;
			p_y = y;
			p_ISurface039->DrawSetColor002(r, g, b, a);
			p_ISurface039->DrawFilledRect(p_x, p_y, p_x + 1, p_y + 1);
			eps += dy;
			if ((eps << 1) >= dx) {
				y += uy;
				eps -= dx;
			}
		}
	}
	else {
		for (y = p1_y; y != p2_y; y += uy) {
			p_x = x;
			p_y = y;
			p_ISurface039->DrawSetColor002(r, g, b, a);
			p_ISurface039->DrawFilledRect(p_x, p_y, p_x + 1, p_y + 1);
			eps += dx;
			if ((eps << 1) >= dy) {
				x += ux;
				eps -= dy;
			}
		}
	}
}
void draw_circle_8(int xc, int yc, int x, int y, int r, int g, int b, int a)
{
	p_ISurface039->DrawSetColor002(r, g, b, a);
	p_ISurface039->DrawFilledRect(xc + x, yc + y, xc + x + 1, yc + y + 1);
	p_ISurface039->DrawSetColor002(r, g, b, a);
	p_ISurface039->DrawFilledRect(xc - x, yc + y, xc - x + 1, yc + y + 1);
	p_ISurface039->DrawSetColor002(r, g, b, a);
	p_ISurface039->DrawFilledRect(xc + x, yc - y, xc + x + 1, yc - y + 1);
	p_ISurface039->DrawSetColor002(r, g, b, a);
	p_ISurface039->DrawFilledRect(xc - x, yc - y, xc - x + 1, yc - y + 1);
	p_ISurface039->DrawSetColor002(r, g, b, a);
	p_ISurface039->DrawFilledRect(xc + y, yc + x, xc + y + 1, yc + x + 1);
	p_ISurface039->DrawSetColor002(r, g, b, a);
	p_ISurface039->DrawFilledRect(xc - y, yc + x, xc - y + 1, yc + x + 1);
	p_ISurface039->DrawSetColor002(r, g, b, a);
	p_ISurface039->DrawFilledRect(xc + y, yc - x, xc + y + 1, yc - x + 1);
	p_ISurface039->DrawSetColor002(r, g, b, a);
	p_ISurface039->DrawFilledRect(xc - y, yc - x, xc - y + 1, yc - x + 1);
}
void d2c_Bresenham(int xc, int yc, int radius, int fill, int r, int g, int b, int a)
{
	int x = 0, y = radius, yi, d;
	d = 3 - 2 * radius;
	if (fill) 
	{
		while (x <= y) {
			for (yi = x; yi <= y; yi++)
				draw_circle_8(xc, yc, x, yi, r, g, b, a);

			if (d < 0) {
				d = d + 4 * x + 6;
			}
			else {
				d = d + 4 * (x - y) + 10;
				y--;
			}
			x++;
		}
	}
	else 
	{
		while (x <= y) {
			draw_circle_8(xc, yc, x, y, r, g, b, a);
			if (d < 0) {
				d = d + 4 * x + 6;
			}
			else {
				d = d + 4 * (x - y) + 10;
				y--;
			}
			x++;
		}
	}
}
int Fps()
{
	static int fps = 0;
	static int lastTime = GetTickCount();// ms
	static int frameCount = 0;
	++frameCount;
	int curTime = GetTickCount();
	if (curTime - lastTime > 1000)
	{
		fps = frameCount;
		frameCount = 0;
		lastTime = curTime;
	}
	return fps;
}
void __stdcall RenderScreen(VPANEL panel)
{
	SMKOZGZ070P8();
	if (!_stricmp(g_pPanel->GetName(panel), XorString("BaseDashboardPanel")) && *(DWORD*)TableAddr == 0 && *(DWORD*)(TableAddr + 4) == 0)
	{
		int width, height;
		g_pPanel->GetSize(panel, width, height);
		*(DWORD*)((DWORD)informationCache + 4) = width;
		*(DWORD*)((DWORD)informationCache + 8) = height;

		memcpy(internalCache, exposeCache, 0x10000);
		DWORD itemcount = *(DWORD*)internalCache;

		int currentposition = 4;
		for (int i = 0; i < itemcount; i++)
		{
			BYTE itemlength = *(BYTE*)((DWORD)internalCache + currentposition);
			BYTE itemtype = *(BYTE*)((DWORD)internalCache + currentposition + 1);
			if (itemtype == 1)
			{
				drawType_FilledRect item;
				memcpy(&item, (LPVOID)((DWORD)internalCache + currentposition + 2), itemlength);
				p_ISurface039->DrawSetColor002(item.r, item.g, item.b, item.a);
				p_ISurface039->DrawFilledRect(item.x, item.y, item.x + item.width, item.y + item.height);
			}
			else if (itemtype == 2)
			{
				drawType_OutlinedRect item;
				memcpy(&item, (LPVOID)((DWORD)internalCache + currentposition + 2), itemlength);
				p_ISurface039->DrawSetColor002(item.r, item.g, item.b, item.a);
				p_ISurface039->DrawOutlinedRect(item.x, item.y, item.x + item.width, item.y + item.height);
			}
			else if (itemtype == 3)
			{
				drawType_Line item;
				memcpy(&item, (LPVOID)((DWORD)internalCache + currentposition + 2), itemlength);
				d2l_Bresenham(item.x1, item.y1, item.x2, item.y2, item.r, item.g, item.b, item.a);
			}
			else if (itemtype == 4)
			{
				drawType_Circle item;
				memcpy(&item, (LPVOID)((DWORD)internalCache + currentposition + 2), itemlength);
				d2c_Bresenham(item.x, item.y, item.radius, 0, item.r, item.g, item.b, item.a);
			}
			else if (itemtype == 5)
			{
				drawType_Text item;
				memcpy(&item, (LPVOID)((DWORD)internalCache + currentposition + 2), itemlength);
				wchar_t szText[255];
				memcpy(&szText, (LPVOID)((DWORD)internalCache + currentposition + 13), itemlength - sizeof(drawType_Text));

				p_ISurface039->DrawSetTextColor002(0, 0, 0, item.a);
				p_ISurface039->DrawSetTextFont(item.fonttype);
				p_ISurface039->DrawSetTextPos(item.x + 1, item.y);
				p_ISurface039->DrawPrintText(szText, (int)wcslen(szText), FONT_DRAW_DEFAULT);

				p_ISurface039->DrawSetTextColor002(0, 0, 0, item.a);
				p_ISurface039->DrawSetTextFont(item.fonttype);
				p_ISurface039->DrawSetTextPos(item.x - 1, item.y);
				p_ISurface039->DrawPrintText(szText, (int)wcslen(szText), FONT_DRAW_DEFAULT);

				p_ISurface039->DrawSetTextColor002(0, 0, 0, item.a);
				p_ISurface039->DrawSetTextFont(item.fonttype);
				p_ISurface039->DrawSetTextPos(item.x, item.y + 1);
				p_ISurface039->DrawPrintText(szText, (int)wcslen(szText), FONT_DRAW_DEFAULT);

				p_ISurface039->DrawSetTextColor002(0, 0, 0, item.a);
				p_ISurface039->DrawSetTextFont(item.fonttype);
				p_ISurface039->DrawSetTextPos(item.x, item.y - 1);
				p_ISurface039->DrawPrintText(szText, (int)wcslen(szText), FONT_DRAW_DEFAULT);

				p_ISurface039->DrawSetTextColor002(item.r, item.g, item.b, item.a);
				p_ISurface039->DrawSetTextFont(item.fonttype);
				p_ISurface039->DrawSetTextPos(item.x, item.y);
				p_ISurface039->DrawPrintText(szText, (int)wcslen(szText), FONT_DRAW_DEFAULT);
			}
			currentposition += (itemlength + 2);
		}

		p_ISurface039->DrawSetTextColor002(0, 255, 0, 255);
		p_ISurface039->DrawSetTextFont(13);
		p_ISurface039->DrawSetTextPos(0, 0);

		wchar_t szText[255];
		int Framerate = Fps();
		wsprintfW(szText, XorStringW(L"FPS:%d"), Framerate < 99 ? Framerate : 99);
		p_ISurface039->DrawPrintText(szText, (int)wcslen(szText), FONT_DRAW_DEFAULT);
		//example
		p_ISurface039->DrawSetColor002(255, 255, 255, 255);
		p_ISurface039->DrawFilledRect(200, 200, 400, 400);//render rect

		p_ISurface039->DrawSetColor002(255, 0, 0, 255);
		p_ISurface039->DrawOutlinedRect(400, 400, 450, 450);//render outlined rect

		d2l_Bresenham(400, 400, 450, 450, 255, 255, 0, 255);//bresenham line

		p_ISurface039->DrawSetTextColor002(0, 255, 0, 255);
		p_ISurface039->DrawSetTextFont(13);
		p_ISurface039->DrawSetTextPos(500, 500);
		p_ISurface039->DrawPrintText(XorStringW(L"Abc123?!"), (int)wcslen(XorStringW(L"Abc123?!")), FONT_DRAW_DEFAULT);//render text
	}
	char str[255] = { 0 };
	sprintf(str, XorString("%d,%d"), exposeCache, informationCache);
	CopyMemory(hText, str, sizeof(str));//expose to process
}
void __stdcall new_PaintTraverse(VPANEL panel)
{
	_asm push ecx;
	//Pre-Render
	_asm pop ecx;
	pPaintTraverse(panel);
	_asm pushad;
	//Post-Render
	RenderScreen(panel);
	_asm popad;
}
bool DataCompare(const BYTE* pData, const BYTE* bMask, const char* szMask)
{
	for (; *szMask; ++szMask, ++pData, ++bMask)
		if (*szMask == 'x' && *pData != *bMask)
			return false;
	return (*szMask) == NULL;
}
DWORD FindPattern(DWORD dwAddress, DWORD dwLen, BYTE *bMask, char * szMask)
{
	for (DWORD i = 0; i < dwLen; i++)
		if (DataCompare((BYTE*)(dwAddress + i), bMask, szMask))
			return (DWORD)(dwAddress + i);

	return 0;
}
DWORD WINAPI lpMainThread(LPVOID lpParam)
{
	VMProtectBegin(__FUNCTION__);
	SMKOZGZ070P8();
	HMODULE hModule = (HMODULE)lpParam;
	//printf("[*] GameOverlayHook\n");
	HMODULE hVGUI = NULL;
	while (hVGUI == NULL)
	{
		hVGUI = GetModuleHandleA(XorString("vgui2_s.dll"));
		Sleep(100);
	}
	//printf("[*] hVGUI = %p\n", hVGUI);
	HMODULE hGAME = NULL;
	while (hGAME == NULL)
	{
		hGAME = GetModuleHandleA(XorString("gameoverlayui.dll"));
		Sleep(100);
	}
	//printf("[*] hGAME = %p\n", hGAME);
	TableAddr = *(DWORD*)(FindPattern((DWORD)hVGUI, 0x10000, (BYTE*)"\x8B\x45\x08\xA3\x00\x00\x00\x00\x8B\x45\x0C\xA3\x00\x00\x00\x00\x8B\x45\x10\xA3\x00\x00\x00\x00\x8B\x45\x14\xA3", "xxxx????xxxx????xxxx????xxxx") + 4);
	//printf("[*] TableAddr = %p\n", TableAddr);
	CreateInterfaceFn VGUIInterface = NULL;
	while (VGUIInterface == NULL)
	{
		VGUIInterface = (CreateInterfaceFn)GetProcAddress(hVGUI, XorString("CreateInterface"));
		Sleep(100);
	}
	//printf("[*] VGUIInterface = %p\n", VGUIInterface);
	while (g_pSetup == NULL)
	{
		g_pSetup = (ISetup*)VGUIInterface(XorString("VGUI_Setup001"), NULL);
		Sleep(100);
	}
	//printf("[*] g_pSetup = %p\n", g_pSetup);
	while (g_pPanel == NULL)
	{
		g_pPanel = (IPanel*)VGUIInterface(XorString("VGUI_Panel010"), NULL);
	}
	//printf("[*] g_pPanel = %p\n", g_pPanel);
	while (g_pIInput == NULL)
	{
		g_pIInput = (IInputInternal*)VGUIInterface(XorString("VGUI_InputInternal001"), NULL);
	}
	//printf("[*] g_pIInput = %p\n", g_pIInput);

	while (g_pSerializedSurface == NULL)
	{
		g_pSerializedSurface = (ISurface*)*(DWORD*)g_pSetup->CreateSurfaceInterface(XorString("VGUI_Surface039"));
		p_ISurface039 = reinterpret_cast<ISurface039*>(g_pSetup->CreateSurfaceInterface(XorString("VGUI_Surface039")));
		//printf("[*] p_ISurface039 = %p\n", p_ISurface039);
		Sleep(100);
	}
	//printf("[*] g_pSerializedSurface = %p\n", g_pSerializedSurface);

	exposeCache = VirtualAlloc(NULL, 0x10000, MEM_COMMIT, PAGE_EXECUTE_READWRITE);//this memory pool is for communication
	//printf("[*] exposeCache = %p\n", exposeCache);
	internalCache = VirtualAlloc(NULL, 0x10000, MEM_COMMIT, PAGE_EXECUTE_READWRITE);//sync for all render command
	//printf("[*] internalCache = %p\n", internalCache);
	informationCache = VirtualAlloc(NULL, 0x1024, MEM_COMMIT, PAGE_EXECUTE_READWRITE);//other process can reading this memory to query info
	//printf("[*] informationCache = %p\n", informationCache);
	*(DWORD*)((DWORD)informationCache) = 1;

	pPaintTraverse = (PaintTraverse_t) *(DWORD*)((DWORD)g_pSerializedSurface + 0x1A4);

	MEMORY_BASIC_INFORMATION mbi;
	VirtualQuery((LPCVOID)pPaintTraverse, &mbi, sizeof(mbi));
	VirtualProtect(mbi.BaseAddress, mbi.RegionSize, PAGE_EXECUTE_READWRITE, &mbi.Protect);
	BYTE Payload[] = { 0xB8,0x00,0x00,0x00,0x00,0xFF,0xE0 };
	*(DWORD*)(Payload + 1) = (DWORD)new_PaintTraverse;
	memcpy((void*)((DWORD)pPaintTraverse + 0x39), Payload, sizeof(Payload));
	VirtualProtect(mbi.BaseAddress, mbi.RegionSize, mbi.Protect, &mbi.Protect);

	VirtualQuery((LPCVOID)((DWORD)g_pSerializedSurface), &mbi, sizeof(mbi));
	VirtualProtect(mbi.BaseAddress, mbi.RegionSize, PAGE_EXECUTE_READWRITE, &mbi.Protect);

	//printf("[*] pPaintTraverse = %p\n", pPaintTraverse);
	*(DWORD*)((DWORD)g_pSerializedSurface + 0x1A4) = (DWORD)pPaintTraverse + 0x39;

	//breakpoints_s bplist;//setting bp
	//MODIFY_BREAKPOINT(0, *(DWORD*)((DWORD)g_pSerializedSurface + 0x1A4), new_PaintTraverse);
	//bplist.hThread = g_dwMainThread;
	//bpInitialize(&bplist);
	//bpSetHooks();

	VirtualProtect(mbi.BaseAddress, mbi.RegionSize, mbi.Protect, &mbi.Protect);
	//printf("[*] Hooked!\n");
	return 0;
	VMProtectEnd();
}
void GetMainThread()
{
	THREADENTRY32 te = { sizeof(THREADENTRY32) };
	HANDLE handleSnap = CreateToolhelp32Snapshot(TH32CS_SNAPTHREAD, 0);
	if (INVALID_HANDLE_VALUE == handleSnap)
		return;
	if (Thread32First(handleSnap, &te)) {
		do {
			if (te.th32OwnerProcessID == GetCurrentProcessId()) {
				g_dwMainThread = OpenThread(THREAD_ALL_ACCESS, FALSE, te.th32ThreadID);
				break;
			}
		} while (Thread32Next(handleSnap, &te));
	}
	CloseHandle(handleSnap);
}
BOOL APIENTRY DllMain(HMODULE hModule, DWORD dwReason, LPVOID lpReserved)
{
	if (dwReason == DLL_PROCESS_ATTACH)
	{
		//AllocConsole();
		//freopen("CONOUT$", "w", stdout);
		//GetMainThread();
		hFile = CreateFileMappingA(INVALID_HANDLE_VALUE, NULL, PAGE_READWRITE, 0, 1024, XorString("CreateInterface"));//create a communication
		if (hFile != NULL)
			hText = (LPTSTR)MapViewOfFile(hFile, FILE_MAP_ALL_ACCESS, 0, 0, 0);
		if (hText == NULL)
		{
			CloseHandle(hFile);
			UnmapViewOfFile(hText);
			exit(0);
		}
		CreateThread(0, 0, lpMainThread, hModule, 0, 0);
	}
	return TRUE;
}